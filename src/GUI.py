import tkinter as tk;
from tkinter.colorchooser import askcolor;
from tkinter.messagebox import showinfo;
from Color import preset_styles;
from CAS.Parser import Parser;
from CAS.Manipulator import Manipulator;
from CAS.Errors import UserError;
from Color import Styles, ColorStyle, preset_styles;

from CartesianFunctions import Function2D, Function3D;
from ParametricFunctions import ParametricFunctionT, ParametricFunctionUV, RevolutionSurface;
from VectorFunctions import VectorField;
from StatisticalPlots import StatPlot2D, StatPlot3D;
from OtherCoordinateSystems import CylindricalFunction, SphericalFunction, PolarFunction;
from ImplicitPlots import ImplicitPlot2D;
from ComplexFunctions import ComplexFunction;
from RecurrenceRelation import RecurrenceRelation;
from Plot import Plot;

from pygame import Color;
from pprint import pprint;
from global_imports import ALLOWED_FUNCTIONS, ALLOWED_COMPLEX_FUNCTIONS;


numerical_parser = Parser(ALLOWED_FUNCTIONS);
expression_parser = Parser(ALLOWED_FUNCTIONS);


FUNCTIONS = [
    "2D function", "3D function", "3D parametric curve", "3D parametric surface",
    "Surface of revolution", "Function with cylindrical coordinates",
    "Function with spherical coordinates", "Vector field", "Polar function",
    "Recurrence relation", "Implicit 2D plot", "Complex function", "Slope field",
];

OTHER_OBJECTS = [
    "2D stat plot", "3D stat plot", "Point", "Plane", "Tangent Plane"
];

OBJECT_TYPES = FUNCTIONS + OTHER_OBJECTS;

REFERENCE_STRINGS = [
    """A map from a single real input to a single real output. Valid symbols: x""",
    """A map from 2 real inputs to a single real output. Valid symbols: x, y""",
    """A curve formed from the points generated by (x(t), y(t), z(t)). Valid symbols: t""",
    """A surface formed from the points generated by (x(u,v), y(u,v), z(u,v)). Valid symbols: u, v""",
    """The surface obtained when the given function of x is rotated about the x axis. Valid symbols: x""",
    """3D generalization of polar coordinates. The radius is a function of an angle and the z value. Valid symbols: z, t""",
    """A function in the spherical coordinate system. The radius is a function of two angles. Valid symbols: t, p""",
    """A map from a point to a vector. Valid symbols: x, y, z""",
    """A function that maps an angle to a radius. Valid symbols: t""",
    """A sequence in which the n+1th output depends on the nth output. Valid symbols: n""",
    """The set of all points in the domain such that the two given functions of x and y are equal. Valid symbols: x, y""",
    """A map from a single complex input to a single complex output. Since there are four dimensions involved, the fourth dimension is represented as color. Valid symbols: z""",
    """The slope field of the given function. Valid symbols: x, y""",
    """A curve formed by a set of numerical points rather than a continuous function""",
    """A surface formed by a mesh of numerical points rather than a continuous function""",
    """A single point in 3D space""",
    """A plane formed from 3 points""",
    """A plane tangent to a function of x and y at a point. Valid Symbols: x, y""",
];

PROMPTS = [
    ("f(x)=",), ("f(x,y)=",), ("x(t)=", "y(t)=", "z(t)="), ("x(u,v)=", "y(u,v)=", "z(u,v)="),
    ("f(x)=",), ("r(z,t)=",), ("r(t,p)=",), ("x(x,y,z)=", "y(x,y,z)=", "z(x,y,z)="), ("r(t)=",),
    ("a(n)=", "seed value: "), ("f(x,y)=", "g(x,y)="), ("f(z)=",), ("f(x,y)=",), ("Enter file name: ",), ("Enter file name: ",),
    ("Enter point in (x, y, z) format: ",), ("Point 1", "Point 2", "Point 3"), ("f(x,y)=", "x=", "y="),
];

SOLID_ONLY = [
    True, False, True, False, False, False, False, True, True, True, True, None, True, True, False, True, False, False,
];

LIGHTING_APPLICABLE = [
    False, True, False, True, True, True, True, False, False, False, False, True, False, False, True, False, False, True,
];

MESHING_APPLICABLE = [
    False, True, False, True, True, True, True, False, False, False, False, True, False, False, True, False, True, True,
];

PARSER_VALID_SYMBOLS = [
    ("x",), ("x", "y"), ("t",), ("u", "v"), ("x",), ("z", "t"), ("t", "p"), ("x", "y", "z"), ("t",),
    ("n",), ("x", "y"), ("z",), ("x", "y"), None, None, None, None, ("x", "y"),
];

PLOT_OBJECTS = [
    Function2D, Function3D, ParametricFunctionT, ParametricFunctionUV,
    RevolutionSurface, CylindricalFunction, SphericalFunction,
    VectorField, PolarFunction, RecurrenceRelation, ImplicitPlot2D,
    ComplexFunction, VectorField.slope_field_of, StatPlot2D, StatPlot3D,
    Plot.add_point, Plot.plane_from_3_points, Plot.tangent_plane,
];

COLOR_TYPES = [
    "solid", "checkerboard", "gradient", "vertical striped", "horizontal striped", "color set",
];

COLOR_CC = [          # (Styles constant, number of required colors)
    (Styles.SOLID, 1), (Styles.CHECKERBOARD, 2), (Styles.GRADIENT, 2),
    (Styles.VERTICAL_STRIPED, 2), (Styles.HORIZONTAL_STRIPED, 2), (Styles.COLOR_SET, 5),
];

COLOR_DATA = dict(zip(COLOR_TYPES, COLOR_CC));

OBJECT_DATA = dict(zip(OBJECT_TYPES, zip(REFERENCE_STRINGS, PROMPTS, SOLID_ONLY, LIGHTING_APPLICABLE, MESHING_APPLICABLE, PARSER_VALID_SYMBOLS, PLOT_OBJECTS)));
##pprint(OBJECT_DATA);

SUBFRAME_COLOR = "#f0f0ff";
BUTTON_COLOR = "#ccccff";
BLINK_COLOR = "#ffcccc";
COLOR_STYLES = [];


def set_text(entry, text, clear=True):
    if clear: entry.delete(0, tk.END);
    entry.insert(0, text);
    

class Interface(tk.Frame):

    """ A tkinter GUI for the grapher. allows user to create plots within the application """

    def __init__(self, master, *args, **kwargs):
        tk.Frame.__init__(self, master, *args, **kwargs);
        self.master = master;
        self.master.title("MathGraph3D");
        self.master.grid_columnconfigure(2, weight=1);
        self.master.grid_columnconfigure(3, weight=1);
        self.objects = [];
        #self.master.iconbitmap("img/torus2.ico");

    def set_plot(self, plot):
        self.plot = plot;
        self.create_widgets();

    def show_message(self, msg, title="Notice", error=False, callback=None):
        """ show a message to the user """
        showinfo(title, "Error: " * error + msg);
        if callable(callback): callback();

    def create_widgets(self):
        """ create widgets for plot bounds, toggles for axes, angles, tracker, spin, and buttons to draw new plots """
        tk.Button(self.master, text="Plot settings", background=BUTTON_COLOR, command=lambda: PlotSettingsWindow(self)).grid(row=0, column=3);
        self.plot_to_open = tk.StringVar(self, value="Add a new object to the plot");
        menu = tk.OptionMenu(self.master, self.plot_to_open, *OBJECT_TYPES, command=self.on_new_plot);
        menu.configure(background=BUTTON_COLOR);
        menu.grid(row=1, column=3);
        self.create_function_frame();

    def on_new_plot(self, event):
        """ called when the user selects a new plot to add """
        plot_type = self.plot_to_open.get();
        
        self.add_object(plot_type);
        self.plot_to_open.set("Add a new object to the plot");

    def create_function_frame(self):
        """ create the frame where the functions on the plot are displayed """
        self.function_frame = tk.Frame(self.master, borderwidth=3, relief="groove", background=SUBFRAME_COLOR);
        tk.Label(self.function_frame, text="Plots currently on the graph: ").grid(row=0, column=0);
        self.function_frame.grid(row=0, column=2, rowspan=6, sticky=tk.N+tk.S+tk.W+tk.E);
        self.function_frame.grid_columnconfigure(0, weight=1);
        self.function_frame_row = 1;

    def add_object(self, object_type):
        """ Add an object to the plot, and create the settings widget for it in the GUI """
        obj = GraphObject(self, self.function_frame, self.function_frame_row, object_type);
        self.GOSWin = GraphObjectSettingsWindow(self, object_type, obj);
        self.function_frame_row += 1;


class GraphObjectSettingsWindow(tk.Toplevel):

    """ A window for configuring the settings of a graph object """

    def __init__(self, master, object_type, assoc_object):
        tk.Toplevel.__init__(self, master);
        self.master = master;
        self.geometry("400x400");
        self.configure(background=SUBFRAME_COLOR);
        self.deiconify();
        self.focus();
        self.enforce = True;

        self.bind("<FocusOut>", self.alarm);
        #self.grab_set();
        
        self.object_type = object_type;
        self.data = OBJECT_DATA[object_type];
        self.associated_object = assoc_object;
        self.text_inputs = {};
        
        self.create_widgets();

    def alarm(self, event):
        """ handle when the user tries to click away """
        if self.enforce:
            pass;
            #self.focus_force();
            #self.blink();

    def blink(self, blinks=3, blink_length=80):
        """ blink the window """
        self.configure(background=BLINK_COLOR);
        for i in range(blinks):
            self.after(blink_length, lambda: self.configure(background=BLINK_COLOR));
            self.after(blink_length, lambda: self.configure(background=SUBFRAME_COLOR));

    def create_input_box(self, frame, label, row):
        """ create a text input box and a label for it """
        tk.Label(frame, text=label).grid(row=row, column=0, sticky=tk.W);
        sv = tk.StringVar(frame);
        self.text_inputs[label] = sv;
        self.add_data(label, sv);
        tk.Entry(frame, textvariable=sv).grid(row=row, column=1, sticky=tk.W);

    def create_widgets(self):
        """ generate widgets from self.data """
        row = 2;
        tk.Label(self, text=self.object_type).grid(row=0, column=0, sticky=tk.W);
        tk.Label(self, text=self.data[0], wraplength=300, justify=tk.LEFT).grid(row=1, column=0, sticky=tk.W);
        input_frame = tk.Frame(self, borderwidth=3, relief="groove", background=SUBFRAME_COLOR);
        for i, prompt in enumerate(self.data[1]):
            self.create_input_box(input_frame, prompt, i);
        input_frame.grid(row=row, sticky=tk.W);
        row += 1;
            
        self.style = tk.StringVar(self, value="select...");
        self.add_data("style", self.style);
        color_frame = tk.Frame(self, borderwidth=3, relief="groove", background=SUBFRAME_COLOR);
        
        if self.data[2]: # solid only
            self.style.set("solid"); 
            self.color_style_set(color_frame, 0);
        elif self.data[2] is None:
            pass;
        else:
            tk.OptionMenu(self, self.style, *(COLOR_TYPES + ["preset"]),
                          command=lambda event: self.color_style_set(color_frame, 0)).grid(row=row, sticky=tk.W);
            row += 1;
            
        color_frame.grid(row=row, sticky=tk.W);
        row += 1;

        if self.data[4]:
            mesh, surf = tk.IntVar(self), tk.IntVar(self);
            mesh.set(1); surf.set(1);
            self.add_data("mesh", mesh);
            self.add_data("surf", surf);
            tk.Checkbutton(self, text="Mesh", var=mesh).grid(row=row, sticky=tk.W);
            tk.Checkbutton(self, text="Surface", var=surf).grid(row=row+1, sticky=tk.W);
            row += 2;

        tk.Button(self, text="Add to Plot", command=self.on_complete).grid(row=row);

    def color_box(self, frame, row, text="Color: ", data_name="fill color"):
        """ create widgets for a color picker """
        def on_color_select(cbox, canv, ask=True):
            nonlocal self;
            if ask: color = askcolor(initialcolor="red", parent=self)[1];
            else: color="#ff0000";
            if not color: return;

            cbox.configure(text=color);
            canv.configure(background=color);
            self.add_data(data_name, Color(color)[0:3]);

        color_box = tk.Label(frame, text="#ff0000", borderwidth=3, relief="flat");
        color_box.grid(row=row, column=1);
        tk.Label(frame, text=text).grid(row=row);
        color_preview = tk.Canvas(frame, width=20, height=20);
        color_preview.grid(row=row, column=3);
        on_color_select(color_box, color_preview, ask=False);
        tk.Button(frame, text="select color", command=lambda: on_color_select(color_box, color_preview, ask=True)).grid(row=row, column=2);

    def add_data(self, name, value):
        """ Add data to the GraphObject associated with this window """
        self.associated_object.obj_data[name] = value;

    def color_style_set(self, frame, row):
        """ Set the widgets when a ColorStyle is chosen """
        value = self.style.get();
        
        for child in frame.winfo_children():
            child.destroy();

        color_count = COLOR_DATA.get(value);
        if color_count is None:
            tk.Label(frame, text="select preset: ").grid(row=row);
            preset = tk.StringVar(frame, value="tmp");
            self.add_data("preset", preset);
            tk.OptionMenu(frame, preset, *sorted(preset_styles.keys()), command=lambda event: None).grid(row=row, column=1);
        else:
            for i in range(1, color_count[1] + 1):
                self.color_box(frame, row, text="Color {}: ".format(i), data_name="color {}".format(i));
                row += 1;
            if self.data[3]:
                lighting = tk.IntVar(frame);
                tk.Checkbutton(frame, text="Apply lighting", var=lighting).grid(row=row);
                self.add_data("lighting", lighting);
                row += 1;

    def on_complete(self):
        """ handle when the user tries to add the object to the plot """
        if not all((box.get() for box in self.text_inputs.values())):
            self.enforce = False;
            self.master.show_message("All text fields must be filled.", error=True);
            self.focus_force();
            self.enforce = True;
        else:
            success = self.associated_object.build_object();
            if success:
                self.associated_object.show();
                self.destroy();
            

class GraphObject:

    """ Any object on the Plot """

    def __init__(self, parent, frame, row, object_type):
        self.parent = parent;
        self.parent_frame = frame;
        self.row = row;
        self.object_type = object_type;
        self.frame = tk.Frame(self.parent_frame, borderwidth=3, relief="groove", background=SUBFRAME_COLOR);
        self.obj = None;
        self.type_data = OBJECT_DATA[self.object_type];
        self.obj_data = {};

    def show(self):
        """ show the graph object widget """
        tk.Label(self.frame, text=self.object_type).grid(row=0, column=0);
        functions = "\n".join((" ".join(f) for f in zip(self.type_data[1], [self.obj_data[prompt].get() for prompt in self.type_data[1]])));
        tk.Label(self.frame, text=functions).grid(row=1, column=0, sticky=tk.W);
        # put edit button in column 2 sticky tk.E
        self.frame.grid(row=self.row, column=0, sticky=tk.E+tk.W);
        
    def build_ColorStyle(self):
        """ Create the ColorStyle object from the data """
        if self.obj_data["style"].get() == "preset":
            return preset_styles[self.obj_data["preset"].get()];

        if self.obj_data["style"].get() == "select...":
            self.obj_data["style"].set("solid");
            self.obj_data["lighting"] = tk.IntVar(value=0);
            self.obj_data["color 1"] = (255, 0, 0)  # set default ColorStyle to solid red
            
        color_data = COLOR_DATA[self.obj_data["style"].get()];
        if color_data[1] == 1:
            colors = {"color": self.obj_data["color 1"]};
        else:
            colors = {"color{}".format(i): self.obj_data["color {}".format(i)] for i in range(1, color_data[1]+1)};
            
        if self.type_data[3]:
            lighting = bool(self.obj_data["lighting"].get());
        else:
            lighting = False;

        return ColorStyle(color_data[0], **colors, apply_lighting=lighting, light_source=(0, 0, 6));

    def build_object(self):
        """ Create a graph object to be added to the plot """
        # Que Daniel Schiffman's "I will refactor this later"
        color_style = self.build_ColorStyle();
        plot = self.parent.plot;

        if self.object_type == "Complex function":
            expression_parser.redefine_functions(**ALLOWED_COMPLEX_FUNCTIONS);
        else:
            expression_parser.redefine_functions(**ALLOWED_FUNCTIONS);

        if self.object_type in FUNCTIONS:
            number_of_functions, params = len(self.type_data[1]), {};
            funcs = self.build_functions(self.type_data[5], number_of_functions);
            if funcs:
                if self.object_type == "Implicit 2D plot":
                    function = self.type_data[6].make_function_string([Manipulator.move_all_terms_to_left(funcs[0], funcs[1])]);
                else:
                    function = self.type_data[6].make_function_string(funcs);
                    
                params["plot"] = plot;
                params["color_style"] = color_style;
                params["function"] = function;
                if self.type_data[4]:
                    params["mesh_on"] = self.obj_data["mesh"].get();
                    params["surf_on"] = self.obj_data["surf"].get();
                if self.object_type == "Recurrence relation":
                    params["seed_value"] = numerical_parser.parse(self.obj_data["seed value: "].get()).evaluate();
                self.obj = self.type_data[6](**params);
                return True;
        else:
            pass;
        
        return False;

    def build_functions(self, symbols, num_functions):
        """ build the functions from GUI input """
        try:
            expression_parser.redefine_symbols(*symbols);
            raw_functions = [self.obj_data[prompt].get() for prompt in self.type_data[1]];
            parsed_functions = [expression_parser.parse(func) for func in raw_functions];
        except UserError as e:
            self.parent.show_message("Invalid function(s)!", error=True, callback=self.parent.GOSWin.lift);
            return False;
        return parsed_functions;


class PlotCreator(tk.Frame):

    """ A tkinter GUI for the grapher. allows user to create plots within the application """

    def __init__(self, master, *args, x_start=-4, x_stop=4, y_start=-4, y_stop=4, z_start=-4, z_stop=4, **kwargs):
        tk.Frame.__init__(self, master, *args, **kwargs);
        self.master = master;
        self.master.title("3D Plotter");
        #self.master.iconbitmap("img/torus2.ico");
        self.update_pending_msg = "NONE";
        self.extra_data = {};

        self.x_start, self.x_stop = x_start, x_stop;
        self.y_start, self.y_stop = y_start, y_stop;
        self.z_start, self.z_stop = z_start, z_stop;

        self.create_widgets();

    def broadcast_to_plotter(self, msg):
        """ tell the plotter it needs to update """
        self.update_pending_msg = msg;

    def show_message(self, msg, error=False):
        """ show a message to the user """
        showinfo("", "Error: " * error + msg);

    def create_widgets(self):
        """ Create widgets for plot bounds, toggles for axes, angles, tracker, spin, and buttons to draw new plots """
        tk.Button(self.master, text="Plot settings", command=lambda: PlotSettingsWindow(self)).grid(row=4,column=2);
        self.create_function_frame();
        self.create_plot_btns();

    def create_function_frame(self):
        """ create the frame where the functions on the plot are displayed """
        self.function_frame = tk.Frame(self.master, borderwidth=3, relief="groove", background="#FFFFFF", height=400);
        tk.Label(self.function_frame, text="Functions currently on the graph: ").grid(row=0, column=0);
        self.function_frame_row = 1;
        self.function_frame.grid(row=0, column=2, rowspan=6, sticky=tk.N);

    def reset_function_frame(self):
        """ reset the function frame """
        self.function_frame.destroy();
        self.create_function_frame();

    def add_to_function_frame(self, function):
        """ add another line to the function display frame """
        tk.Label(self.function_frame, text=function).grid(row=self.function_frame_row, column=0, sticky=tk.W);
        self.function_frame_row += 1;

    def create_plot_btns(self):
        """ create buttons to add functions to the plot """
        frame = tk.Frame(self.master, borderwidth=3, relief="groove");
        frame.grid(row=3, column=2);

        i = 0;
        for text, plot_type in [("New 2D plot", "2D plot"), ("New 3D plot", "3D plot"), ("New parametric function (1 parameter)", "parametric: 1 param"),
                                ("New parametric function (2 parameters)", "parametric: 2 params"), ("New revolution surface", "revolution surface"),
                                ("New function of cylindrical coordinates", "cylindrical function"), ("New function of spherical coordinates", "spherical function"),
                                ("New vector field", "vector field")]:
            tk.Button(frame, text=text, command=lambda plot_type=plot_type: NewPlotWindow(self, plot_type)).grid(row=i, column=0, padx=10, pady=5);
            i += 1;
        tk.Button(frame, text="Compile new function", command=lambda: DefineFunctionWindow(self)).grid(row=i, column=0, pady=5);


class PlotSettingsWindow(tk.Toplevel):

    """ Window to input the settings for the plot view """

    def __init__(self, parent):
        tk.Toplevel.__init__(self, parent);
        self.parent = parent;
        self.title("Plot settings");
        #self.iconbitmap("img/torus2.ico");
        self.create_widgets();

    def create_widgets(self):
        """ create all the window's widgets """
        self.create_plot_bounds();
        self.create_toggles();
        tk.Button(self, text="Close", command=self.destroy).grid(row=2, column=0);

    def create_plot_bounds(self):
        """ create the widgets for plot bounds """
        def onchange(event, name):
            setattr(self.parent, name, int(event));
            self.parent.broadcast_to_plotter("UPDATE_PLOT_SETTINGS");

        frame = tk.Frame(self, borderwidth=3, relief="groove");
        frame.grid(row=0, column=0, padx=10, pady=10);

        widget_data = (
            ("x_start", True,  "x start value: ", 0, 0),
            ("x_stop",  False, "x stop value: ",  0, 2),
            ("y_start", True,  "y start value: ", 1, 0),
            ("y_stop",  False, "y stop value: ",  1, 2),
            ("z_start", True,  "z start value: ", 2, 0),
            ("z_stop",  False, "z stop value: ",  2, 2)
        );

        for name, start, text, row, col in widget_data:
            from_, to = (-10, -1) if start else (1, 10);
            widget = tk.Scale(frame, from_=from_, to=to, orient=tk.HORIZONTAL, command=lambda event, name=name: onchange(event, name));
            label = tk.Label(frame, text=text);

            label.grid(row=row, column=col);
            widget.grid(row=row, column=col+1);

            widget.set(getattr(self.parent, name));

    def create_toggles(self):
        """ create toggle buttons for axes, angles, tracker, and spin """
        frame = tk.Frame(self, borderwidth=3, relief="groove");
        i = 0;
        for text, broadcast in [("Toggle axes", "TOGGLE_AXES"), ("Toggle angles", "TOGGLE_ANGLES"),
                                ("Toggle tracker", "TOGGLE_TRACKER"), ("Toggle spin", "TOGGLE_SPIN"),
                                ("Toggle frame", "TOGGLE_CUBE"), ("Reset plots", "RESET_PLOTS")]:
            tk.Button(frame, text=text, command=lambda broadcast=broadcast: self.parent.broadcast_to_plotter(broadcast)).grid(row=0, column=i, padx=2);
            i += 1;
        frame.grid(row=1, column=0, pady=10, padx=10);


class DefineFunctionWindow(tk.Toplevel):

    """ Window for defining a new function """

    def __init__(self, parent):
        tk.Toplevel.__init__(self, parent);
        self.parent = parent;
        self.title("Define a function");
        #self.iconbitmap("img/torus2.ico")

        self.geometry("400x400");
        self.deiconify();
        self.radio_btn_state = tk.IntVar();
        self.radio_btn_state.initialize(1);
        self.function_entry_state = tk.StringVar();
        self.function_label_text = tk.StringVar(value="f(x)=");
        self.function_name_state = tk.StringVar();
        self.create_widgets();

    def create_widgets(self):
        """ add all widgets needed for the window """
        self.msg = tk.StringVar(self, value="Define a new function");
        tk.Label(self, textvariable=self.msg).grid(row=0, column=0);
        tk.Radiobutton(self, text="one variable", variable=self.radio_btn_state, value=1, command=lambda: self.function_label_text.set("f(x)=")).grid(row=1, column=0);
        tk.Radiobutton(self, text="two variables", variable=self.radio_btn_state, value=2, command=lambda: self.function_label_text.set("f(x,y)=")).grid(row=1, column=1);
        tk.Radiobutton(self, text="three variables", variable=self.radio_btn_state, value=3, command=lambda: self.function_label_text.set("f(x,y,z)=")).grid(row=1, column=2);
        tk.Label(self, text="Name: ").grid(row=2, column=0, sticky=tk.W);
        tk.Entry(self, textvariable=self.function_name_state).grid(row=2, column=1, sticky=tk.W);
        tk.Label(self, textvariable=self.function_label_text).grid(row=3, column=0, sticky=tk.W);
        tk.Entry(self, textvariable=self.function_entry_state).grid(row=3, column=1, sticky=tk.W);
        tk.Button(self, text="Add", command=self.on_close).grid(row=4, column=0, sticky=tk.W);

    def on_close(self):
        """ send data to the plotter and tell it a new function should be created. then destroy the window """
        function = self.function_entry_state.get();
        function_name = self.function_name_state.get();
        rbtn_state = self.radio_btn_state.get();

        if function and function_name:
            self.add_data("function", function);
            self.add_data("num vars", rbtn_state);
            self.add_data("function name", function_name);
            self.parent.broadcast_to_plotter("NEW_COMPILED_FUNCTION");
            self.destroy();
        else:
            self.show_message("function box and name box cannot be blank", True);
            return;

    def add_data(self, name, data):
        """ add data to be broadcast to the plotter """
        self.parent.extra_data[name] = data;

    def show_message(self, msg, error=False):
        """ display a message to the user """
        self.msg.set("Error: " * error + msg);

class NewPlotWindow(tk.Toplevel):

    """ Window to input the settings for a new plot """

    def __init__(self, parent, type_):
        tk.Toplevel.__init__(self, parent);
        self.parent = parent;
        self.title(type_);
        #self.iconbitmap("img/torus2.ico");
        self.type = type_;

        self.geometry("400x400+200+200");
        self.deiconify();

        if self.type == "2D plot":
            self.set_up_configurations(["f(x)="], "NEW_2D_FUNCTION", solid_only=True);
        elif self.type == "3D plot":
            self.set_up_configurations(["f(x,y)="], "NEW_3D_FUNCTION");
        elif self.type == "parametric: 1 param":
            self.set_up_configurations(["x(t)=", "y(t)=", "z(t)="], "NEW_PARAM1_FUNCTION", solid_only=True);
        elif self.type == "parametric: 2 params":
            self.set_up_configurations(["x(u,v)=", "y(u,v)=", "z(u,v)="], "NEW_PARAM2_FUNCTION");
        elif self.type == "revolution surface":
            self.set_up_configurations(["f(x)="], "NEW_REVOLUTION_SURFACE");
        elif self.type == "cylindrical function":
            self.set_up_configurations(["r(z,t)="], "NEW_CYL_FUNCTION");
        elif self.type == "spherical function":
            self.set_up_configurations(["r(t,p)="], "NEW_SPH_FUNCTION");
        elif self.type == "vector field":
            self.set_up_configurations(["x(x,y,z)=", "y(x,y,z)=", "z(x,y,z)="], "NEW_VECTOR_FIELD");

    def add_data(self, name, data):
        """ add data to be broadcast to the plotter """
        self.parent.extra_data[name] = data;

    def light_source(self, row=0):
        """ draw the widgets for light source configuring """
        data = (
            ("x", self.parent.x_start, self.parent.x_stop, "light_source_x", 0),
            ("y", self.parent.y_start, self.parent.y_stop, "light_source_y", 0),
            ("z", self.parent.z_start, self.parent.z_stop, "light_source_z", 6)
        );

        self.light_source_frame = tk.Frame(self, borderwidth=3, relief="groove");
        self.light_source_frame.grid(row=row, sticky=tk.W);

        tk.Label(self.light_source_frame, text="Light source position");
        row = 1;
        for text, from_, to, name, default in data:
            start = min(-8, from_);
            stop = max(8, to);

            widget = tk.Scale(self.light_source_frame, from_=start, to=stop, orient=tk.HORIZONTAL, command=lambda event, name=name: self.add_data(name, int(event)));
            label = tk.Label(self.light_source_frame, text=text);

            label.grid(row=row);
            widget.grid(row=row, column=1);
            widget.set(default);
            row += 1;

    def destroy_light_source(self):
        """ remove the widgets for light source configuring """
        if hasattr(self, "light_source_frame"):
            self.light_source_frame.destroy();

    def color_style(self, row=0, solid_only=False):
        """ Draw the widgets for ColorStyle configuring """
        def on_check(lighting):
            nonlocal row;
            value = lighting.get();
            self.add_data("apply_lighting", value);
            if value: self.light_source(row+1);
            else: self.destroy_light_source();

        cs_frame = tk.Frame(self, borderwidth=3, relief="groove");
        dframe = tk.Frame(cs_frame);
        dframe.grid(row=2);
        tk.Label(cs_frame, text="Color Style").grid(row=0, sticky=tk.W);
        cs_frame.grid(row=row, sticky=tk.W);

        self.style = tk.StringVar(dframe, value="select...");
        if solid_only:
            self.style.set("solid");
            self.color_style_set(dframe, row+1);
        else:
            tk.OptionMenu(cs_frame, self.style, "solid", "checkerboard", "gradient",
                          "vertical striped", "horizontal striped", "color set", "preset",
                          command=lambda event: self.color_style_set(dframe, row+1)).grid(row=1, sticky=tk.W);

            lighting = tk.IntVar();
            tk.Checkbutton(cs_frame, text="Apply lighting", var=lighting,
                           command=lambda lighting=lighting: on_check(lighting)).grid(row=3, sticky=tk.W);

    def color_box(self, frame, row, text="Color: ", data_name="fill color"):
        """ create widgets for a color picker """
        def on_color_select(cbox, canv, ask=True):
            nonlocal self;
            if ask: color = askcolor(initialcolor="red",  parent=self)[1];
            else: color="#ff0000";
            if not color: return;

            cbox.configure(text=color);
            canv.configure(background=color);
            self.add_data(data_name, Color(color)[0:3]);

        color_box = tk.Label(frame, text="#ff0000", borderwidth=3, relief="flat");
        color_box.grid(row=row, column=1);
        tk.Label(frame, text=text).grid(row=row);
        color_preview = tk.Canvas(frame, width=20, height=20);
        color_preview.grid(row=row, column=3);
        on_color_select(color_box, color_preview, ask=False);
        tk.Button(frame, text="select color", command=lambda: on_color_select(color_box, color_preview, ask=True)).grid(row=row, column=2);

    def color_style_set(self, frame, row):
        """ Set the widgets for a specific ColorStyle """
        value = self.style.get();
        self.add_data("plot type", value);
        for child in frame.winfo_children():
            child.destroy();

        if value == "solid":
            self.color_box(frame, row);
        elif value in ("checkerboard", "gradient", "vertical striped", "horizontal striped"):
            cbox1 = self.color_box(frame, row, text="Color 1: ", data_name="color 1");
            cbox2 = self.color_box(frame, row+1, text="Color 2: ", data_name="color 2");
        elif value == "color set":
            self.color_box(frame, row, text="Color 1: ", data_name="color 1");
            self.color_box(frame, row+1, text="Color 2: ", data_name="color 2");
            self.color_box(frame, row+2, text="Color 3: ", data_name="color 3");
            self.color_box(frame, row+3, text="Color 4: ", data_name="color 4");
            self.color_box(frame, row+4, text="Color 5: ", data_name="color 5");
        elif value == "preset":
            tk.Label(frame, text="select preset: ").grid(row=row);
            preset = tk.StringVar(frame, value="tmp");
            self.add_data("plot type", preset.get());
            tk.OptionMenu(frame, preset, *sorted(preset_styles.keys()), command=lambda event: self.add_data("plot type", preset.get())).grid(row=row, column=1);

    def on_complete(self, data, broadcast):
        """ Send the neccesary data to the plotter and notify it that a new plot should be created. Then destroy the window """
        for name, data_item in data.items():
            if name.startswith("function") and not len(data_item):
                self.show_message("Function box cannot be blank!", error=True);
                return;
            self.add_data(name, data_item);
        self.parent.broadcast_to_plotter(broadcast);
        self.destroy();

    def create_function_boxes(self, labels, row=0):
        """ create the input boxes for the functions """
        frame = tk.Frame(self, borderwidth=3, relief="groove");
        functions = [];
        for i, label in enumerate(labels):
            tk.Label(frame, text=label).grid(row=i, column=0);
            func = tk.Entry(frame);
            func.grid(row=i, column=1);
            functions.append(func);
        frame.grid(row=row, sticky=tk.W);
        return functions;

    def show_message(self, msg, error=False):
        """ display a message to the user """
        self.msg.set("Error: " * error + msg);

    def set_up_configurations(self, function_boxes, broadcast_msg, solid_only=False):
        """ Set up the widgets for adding a new function of any type """
        self.add_data("plot type", "solid");
        self.add_data("fill color", (255, 0, 0));

        frame = tk.Frame(self, borderwidth=3, relief="groove");
        frame.grid(row=0, column=0);
        self.msg = tk.StringVar(frame, value="Add a graph to the plot");
        tk.Label(frame, textvariable=self.msg).grid(row=0);

        strings = self.create_function_boxes(function_boxes, row=1);
        self.color_style(row=2, solid_only=solid_only);
        tk.Button(self, text="Add to plot", command=lambda: self.on_complete({"function {}".format(i+1): strings[i].get() for i in range(len(strings))}, broadcast_msg)).grid(row=4);
